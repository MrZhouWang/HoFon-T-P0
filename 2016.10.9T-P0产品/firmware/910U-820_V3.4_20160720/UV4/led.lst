C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LED
OBJECT MODULE PLACED IN .\led.obj
COMPILER INVOKED BY: D:\Program Files\KEIL4\C51\BIN\C51.EXE ..\src\led.c BROWSE DEBUG OBJECTEXTEND PRINT(.\led.lst) OBJE
                    -CT(.\led.obj)

line level    source

   1          
   2          #define AP_LED_GLOBALS  
   3          #include "extern_symbol.h" 
   4          #include "ASCII_Led.h"                                             // ASCII 码表对应数码管
   5          
   6          // 函数声明
   7          void    Digi_DotLed_Disp(void);
   8          void    DispBuffrefresh_AD(void);
   9          void    DispBuffrefresh_F1(void);
  10          void    DispBuffrefresh_F2(void);
  11          void    DispBuffrefresh_F3(void);
  12          void    DispBuffrefresh_F4(void);
  13          void    DispBuffrefresh_F5(void);
  14          void    DispBuffrefresh_FnCom(INT8U fn);
  15          void    DispBuffrefresh_OFF(void);
  16          
  17          // 各机型对应不同的地方
  18          //==============================================================================
  19          // 无数码管显示
  20          #if     ( (MACHINETYPE == P0_910U)||(MACHINETYPE == A0_820) )
  21          // 无数码管扫描
  22          void led_Scan(void)
  23          { return; }
  24          // 无数码管初始化
  25          void digital_led_cntrl_Init(void)
  26          { return; }
  27          // 无版本显示
  28          void    DispVersion(void)
  29          { return; }
  30          // 无数码管段位显示
  31          void    DispLedBit(void)
  32          { return; }
  33          // 无开机参数显示
  34          void Display_Para_AD_Fn(void)
  35          { return; }
  36          // 无数码管电源关闭
  37          void All_Digital_Led_Pwr_OFF(void)
  38          { return; }
  39          // 无显示芯片刷新
  40          void    Digi_DotLed_Disp(void)
  41          { return; }
  42          
  43          //void  Disp_Roll_Process(void)
  44          //{ return; }
  45          //==============================================================================
  46          // 有数码管显示
  47          #else
              /*******************************************************************************
                                                              显示address和F1~F4参数
                  input:   none     
                      output:  none
              *******************************************************************************/
              void Display_Para_AD_Fn(void)
              {
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 2   

              //      Disp.DatSel = 0;
                      INT8U   i ;
              
                      DispBuffrefresh_AD();
                      Digi_DotLed_Disp();
                      DelayMs(1000);                                          // 延时1000ms
                      
                      for (i = 1; i < MAX_CFGPARA; i++)
                      {
                              DispBuffrefresh_FnCom(i);
                              Digi_DotLed_Disp();
                              DelayMs(1000);                                          // 延时1000ms
                      }
              //      DispBuffrefresh_F1();
              //      Digi_DotLed_Disp();
              //      DelayMs(1000);                                          // 延时1000ms
              //      
              //      DispBuffrefresh_F2();
              //      Digi_DotLed_Disp();
              //      DelayMs(1000);                                          // 延时1000ms
              //                                      
              //      DispBuffrefresh_F3();
              //      Digi_DotLed_Disp();
              //      DelayMs(1000);                                          // 延时1000ms
              //      
              //      DispBuffrefresh_F4();
              //      Digi_DotLed_Disp();
              //      DelayMs(1000);                                          // 延时1000ms
              //
              //      DispBuffrefresh_F5();
              //      Digi_DotLed_Disp();
              //      DelayMs(1000);                                          // 延时1000ms
              }       
                      
              // 段式数码管显示       
                      #if( (MACHINETYPE == P3_910U)||(MACHINETYPE == P6_910U)||(MACHINETYPE == P6_910U_G3R3)||(MACHINETYPE == A
             -2_820)||(MACHINETYPE == A4_820)||(MACHINETYPE == P3_920U)||(MACHINETYPE == P6_920U)||(MACHINETYPE == P6_920U_G3R3)||(MAC
             -HINETYPE == P6_910U_R6) )
              
              // 无需刷新,在定时里用  led_Scan()；刷新显示芯片
              void    Digi_DotLed_Disp(void)
              { return; }
              
              //void  Disp_Roll_Process(void)
              //{ return; }
              /*******************************************************************************
                                                              显示版本
                  input:   none     
                      output:  none
              *******************************************************************************/
              void    DispVersion(void)
              {
                      INT8U   i;
                      for (i = DIGILED_FIRST; i < LED_NUMBER; i++)
                      { DigiLed.num[i]   = Version[i]; }
                      DelayMs(800);                                     // 延时800ms
              }
              
              /*******************************************************************************
                                                              显示各段码
                  input:   none     
                      output:  none
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 3   

              *******************************************************************************/
              INT8U  CODE   LEDSecBit[7] = {37,38,39,40,41,42,36};            //段码对应的LED库表
              void    DispLedBit(void)
              {
                      INT8U   i,j;
                      for(i = 0; i < 7; i++)
                      {
                              for(j = DIGILED_FIRST; j < LED_NUMBER; j++)
                              { DigiLed.num[j]   = LEDSecBit[i]; }             //段码亮
                                                  
                              DelayMs(300);    //延时150显示
                      }
              }
              
              
              /*******************************************************************************
                                          LED数码管SPI控制IO初始化
                  Input :      None
                  Output:  None       
              *******************************************************************************/
              void digital_led_cntrl_Init(void)
              {       
                      OE_SET;                 //DISABLE
                      SH_CLK_CLR;
                      ST_CLK_CLR;
                      OE_CLR;                 //ENALBE
              
              }
              
              /*******************************************************************************
                                          LED数码管 关闭所有电源
                  Input :      None
                  Output:  None       
              *******************************************************************************/
              void All_Digital_Led_Pwr_OFF(void)
              {
                      DIGITAL_LED1_OFF;               //LED 0 ==> OFF
              //      LED_PORT_OUT |= 0x1f;                                                   //LED 1-LED5 ==> OFF
                      DIGITAL_LED2_OFF;               //LED 1 ==> OFF
                      DIGITAL_LED3_OFF;               //LED 2 ==> OFF
                      DIGITAL_LED4_OFF;               //LED 3 ==> OFF
                      DIGITAL_LED5_OFF;               //LED 4 ==> OFF
                      DIGITAL_LED6_OFF;               //LED 5 ==> OFF
              }
              /*******************************************************************************
                                          显示当前扫描的led内容          
                  Input :      UINT8 ucValue   //当前要显示的数值
                  Output:  None       
              *******************************************************************************/
              void led_Show(UINT8 ucValue)
              {
                      UINT8 i;
              
                      ST_CLK_CLR;
                      for (i = 0; i < 8; i++)
                      {
                              if (ucValue & 0x80)
                                      SDATA_SET;
                              else
                                      SDATA_CLR;
                              SH_CLK_CLR;
                              NOP; NOP; NOP; NOP;
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 4   

                              SH_CLK_SET;
                              ucValue = ucValue << 1; 
                      }
              //      led_SupplyPower();                                                    //供电
                      ST_CLK_SET;
              }
              
              /*******************************************************************************
                                          显示一个digital led         
                  Input :               None
                  Output:         None
                  Description:  显示一个数码管数字，扫描时间: 72us         
              *******************************************************************************/
              
              void led_Scan(void)
              {
                  UINT8 ucValue;
              
              //    if (sys.led_scan_flag == OFF) return;
              //    sys.led_scan_flag = OFF;
              
                  if( (++DigiLed.Order) >= LED_NUMBER ) 
                  { DigiLed.Order = DIGILED_FIRST; }
              
                      ucValue = DigiLed.num[DigiLed.Order];
                      if(ucValue >= LED_TBL_MAX )
                      { ucValue = LED_TBL_MAX-1; }
              
                      // 全关闭所有显示电源
                      All_Digital_Led_Pwr_OFF();
                      // 对应显示数据送入595
                  led_Show(LED_TBL[ucValue]);                                         //取表的值 送入595
                      //对应数码管供电
              //      led_SupplyPower();                                                      //对应数码管供电
                      switch(DigiLed.Order)
                      {
                              case DIGITAL_LED1:  DIGITAL_LED1_ON; break;               //个位数码管电源
                              case DIGITAL_LED2:  DIGITAL_LED2_ON; break;               //十位数码管电源
                              case DIGITAL_LED3:  DIGITAL_LED3_ON; break;               //百位数码管电源
                              case DIGITAL_LED4:  DIGITAL_LED4_ON; break;               //千位数码管电源
                              case DIGITAL_LED5:  DIGITAL_LED5_ON; break;               //万位数码管电源
                              default:                        DIGITAL_LED6_ON; break;           //十万位数码管电源
                      }
              }
              //==============================================================================
              // 段式数码管显示
                      #elif( (MACHINETYPE == P10_910U)||(MACHINETYPE == P10_910U_R10)||(MACHINETYPE == A10S_820) )
              // 无数码管扫描
              void led_Scan(void)
              { return; }
              // 无数码管电源关闭
              void All_Digital_Led_Pwr_OFF(void)
              { return; }
              
              /*******************************************************************************
                                          HT1632芯片发命令前
                      //送控制码 100给 HT1632;->要改变HT1632钐前要先送 100o1632
                  Input :      None
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_PRECOMMAND(void)                                                                                                                                                                                              
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 5   

              {
                      // 1
                      HT1632_WR_L;
                      HT1632_DATA_H;
                      HT1632_WR_H;
                      // 0
                      HT1632_WR_L;
                      HT1632_DATA_L;
                      HT1632_WR_H;
                      // 0
                      HT1632_WR_L;
                      HT1632_DATA_L;
                      HT1632_WR_H;
              }
              /*******************************************************************************
                                          HT1632芯片更新RAM前
                      //送控制码 101给 HT1632;->要更新HT1632 RAM前要先送 101o1632
                  Input :      None
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_PREDATA(void) 
              {
                      // 1
                      HT1632_WR_L;
                      HT1632_DATA_H;
                      HT1632_WR_H;
                      // 0
                      HT1632_WR_L;
                      HT1632_DATA_L;
                      HT1632_WR_H;
                      // 1
                      HT1632_WR_L;
                      HT1632_DATA_H;
                      HT1632_WR_H;
              }
              /*******************************************************************************
                                          送资料码给 HT1632前要先指定位址
                  Input :      address  地址
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_ADDRESS(INT8U address)
              {       
                      INT8U i;
                      //地址取低7位 //先送高位
                      for(i = 0 ; i < 7 ; i++)
                      {
                              address <<= 1;                                                     // 不要高位
                              HT1632_WR_L;                               //clk = 0 for data ready
                              if((address & 0x80) == 0)  HT1632_DATA_L;
                              else                       HT1632_DATA_H;
                              HT1632_WR_H;                              //clk = 1 for data write into 1632            
                      }
              }
              /*******************************************************************************
                                          送数据给 HT1632
                  Input :      data  数据
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_DATA(INT8U dat)
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 6   

              {       
                      INT8U i;
                      //先送高位
                      for(i = 0 ; i < 8 ; i++)
                      {
                              HT1632_WR_L;                               //clk = 0 for data ready
                              if((dat & 0x80) == 0)  HT1632_DATA_L;
                              else                   HT1632_DATA_H;
                              HT1632_WR_H;                              //clk = 1 for data write into 1632
                              dat <<= 1;
                      }
              }
              
              /*******************************************************************************
                                          设定HT1632的所有RAM为同一个数值
                  Input :      addr 起始地址，len写入长度，dat写入数据 
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_Write_AddrLenDat(INT8U cs,INT8U addr,INT8U len,INT8U dat)
              {
                      INT8U i;
              
                      switch(cs)
                      {
                              case HT1632_CS1: HT1632_CS1_L; break;//1632 CS0 enable                                  
                              case HT1632_CS2: HT1632_CS2_L; break;//1632 CS1 enable                                                          
                      }
              //   HT1632_CS1_L;        //1632 CS0 enable
              //   HT1632_CS2_L;        //1632 CS1 enable
                 
                      HT1632_PREDATA();               // "101" , ready for write
                      HT1632_ADDRESS(addr);         // address = 0
                      for(i=0 ; i<len ; i++)
                      {
                        HT1632_DATA(dat);             //all RAM write 1
                      }
              
                      switch(cs)
                      {
                              case HT1632_CS1: HT1632_CS1_H; break;//1632 CS0 disable                                 
                              case HT1632_CS2: HT1632_CS2_H; break;//1632 CS1 disable                                                         
                      }
              //   HT1632_CS1_H;       //1632 CS disable
              //   HT1632_CS2_H;       //1632 CS disable
              }
              
              /*******************************************************************************
                                          把存储区数据写入HT1632RAM区
                  Input :      addr 起始地址，len写入长度，ptr存储区首地址 
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_Write_AddrLenPtr(INT8U cs,INT8U addr,INT8U len,INT8U XDATA *ptr)
              {
                      INT8U i;
              
                      switch(cs)
                      {
                              case HT1632_CS1: HT1632_CS1_L; break;//1632 CS0 enable                                  
                              case HT1632_CS2: HT1632_CS2_L; break;//1632 CS1 enable                                                          
                      }
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 7   

              //   HT1632_CS1_L;        //1632 CS0 enable
              //   HT1632_CS2_L;        //1632 CS1 enable
                 
                      HT1632_PREDATA();               // "101" , ready for write
                      HT1632_ADDRESS(addr);         // address = 0
                      for(i=0 ; i<len ; i++)
                      {
                              HT1632_DATA(*(ptr+i));          //all RAM write 1
                      }
              
                      switch(cs)
                      {
                              case HT1632_CS1: HT1632_CS1_H; break;//1632 CS0 disable                                 
                              case HT1632_CS2: HT1632_CS2_H; break;//1632 CS1 disable                                                         
                      }
              //   HT1632_CS1_H;       //1632 CS disable
              //   HT1632_CS2_H;       //1632 CS disable
              }
              /*******************************************************************************
                                          设定HT1632的所有RAM为同一个数值
                  Input :      ToSetData  要设置的数据
                  Output:  None       
              *******************************************************************************/
              
              void HT1632_ALLRAM_OFF(void)
              {
                      HT1632_Write_AddrLenDat(HT1632_CS1,0x00,32,0x00);                 // 从地址00开始写入32个0
                      HT1632_Write_AddrLenDat(HT1632_CS2,0x00,32,0x00);                 // 从地址00开始写入32个0
              }
              
              /*******************************************************************************
                                          送命令码给 HT1632
                  Input :      command  命令码
                  Output:  None       
              *******************************************************************************/
              void HT1632_COMMAND(INT8U command)
              {
                      INT8U i;
                      //先送高位
                      for(i = 0 ; i < 8 ; i++)
                      {
                              HT1632_WR_L;                               //clk = 0 for data ready
                              if((command & 0x80) == 0)  HT1632_DATA_L;
                              else                       HT1632_DATA_H;
                              HT1632_WR_H;                              //clk = 1 for data write into 1632
                              command <<= 1;
                      }
                      HT1632_WR_L;
                      // _nop();
                      // _nop();
                      HT1632_WR_H;    // X
              }
              /*******************************************************************************
                                          LED阵列HT1632芯片初始化
                  Input :      None
                  Output:  None       
              *******************************************************************************/
              void HT1632_INIT_NO(INT8U HT1632No)
              {
                      switch(HT1632No)
                      {
                              case HT1632_CS1: HT1632_CS1_L; break;//1632 CS0 enable                                  
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 8   

                              case HT1632_CS2: HT1632_CS2_L; break;//1632 CS1 enable                                                          
                      }
                      
                  HT1632_PRECOMMAND();                                         // 发命令前提前发100
                  HT1632_COMMAND(C_COMMAND1632_SYSEN);     //SYSTEM ENABLE
                  switch(HT1632No)
                  {
                              case HT1632_CS1:
                                      HT1632_COMMAND(C_COMMAND1632_N_8COM);    //P-MOS OUTPUT AND 16COMMON OPTION     
                                      HT1632_COMMAND(C_COMMAND1632_MST_M);      //MASTER MODE
                                      break;
                              case HT1632_CS2:
                                      HT1632_COMMAND(C_COMMAND1632_N_8COM);  //P-MOS OUTPUT AND 16COMMON OPTION
                                      HT1632_COMMAND(C_COMMAND1632_SLV_M);    //SLAVE MODE                    
                                      break;
                      }
                  HT1632_COMMAND(C_COMMAND1632_LEDON);     //LED ON
                  HT1632_COMMAND(C_COMMAND1632_BLINKOFF);  //BLINK OFF
                  HT1632_COMMAND(C_COMMAND1632_PWMDUTY);   //PWM DUTY SET
              
                      switch(HT1632No)
                      {
                              case HT1632_CS1: HT1632_CS1_H; break;//1632 CS0 disable                                 
                              case HT1632_CS2: HT1632_CS2_H; break;//1632 CS1 disable                                                         
                      }       
              }
              /*******************************************************************************
                                          LED阵列HT1632芯片初始化
                  Input :      None
                  Output:  None       
              *******************************************************************************/
              void digital_led_cntrl_Init(void)
              {       
                      // IO口初始化
                      HT1632_CS1_H;
                      HT1632_CS2_H;
                      HT1632_RD_H;
                      HT1632_WR_H;
                      HT1632_DATA_H;
              
                      HT1632_INIT_NO(HT1632_CS1);              // 芯片1初始化
                      HT1632_INIT_NO(HT1632_CS2);              // 芯片2初始化
              }
              
              /*******************************************************************************
                                                              显示版本
                  input:   none     
                      output:  none
              *******************************************************************************/
              void    DispVersion(void)
              {
              //      TextOutCountArea("V3.0",4);
                      INT8U   i;
                      DispBuffrefresh_OFF();          // 灭全部显示
                      for (i = DIGILED_FIRST; i < LED_NUMBER; i++)
                      { DigiLed.num[i]   = Version[i]; }
                      Digi_DotLed_Disp();
                      DelayMs(800);    //延时800显示
              }
              
              /*******************************************************************************
                                                              显示各段码
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 9   

                  input:   none     
                      output:  none
              *******************************************************************************/
              
              void    DispLedBit(void)
              {
                      //清屏
                      HT1632_ALLRAM_OFF();
              
              //      //全亮 先亮2个 再亮4个
              //      HT1632_Write_AddrLenDat(0x00,8,0xff);
              //      DelayMs(360);   
              //      HT1632_Write_AddrLenDat(0x10,8,0xff);
              //      DelayMs(660);
              //      //全灭
              //      HT1632_ALLRAM_OFF();
              //      DelayMs(100);
              //      //全亮 先亮2个 再亮4个
              //      HT1632_Write_AddrLenDat(0x20,8,0xff);
              //      DelayMs(360);   
              //      HT1632_Write_AddrLenDat(0x30,8,0xff);
              //      DelayMs(660);
              
                      HT1632_Write_AddrLenDat(HT1632_CS1,0x00,16,0xff);
                      DelayMs(525);   HT1632_ALLRAM_OFF();
              //      HT1632_Write_AddrLenDat(HT1632_CS1,0x10,8,0xff);
              //      DelayMs(300);   HT1632_ALLRAM_OFF();
                      HT1632_Write_AddrLenDat(HT1632_CS1,0x20,16,0xff);
                      DelayMs(525);   HT1632_ALLRAM_OFF();
              //      HT1632_Write_AddrLenDat(HT1632_CS1,0x30,8,0xff);
              //      DelayMs(300);   HT1632_ALLRAM_OFF();
              
                      HT1632_Write_AddrLenDat(HT1632_CS2,0x00,16,0xff);
                      DelayMs(525);   HT1632_ALLRAM_OFF();
              //      HT1632_Write_AddrLenDat(HT1632_CS2,0x10,8,0xff);
              //      DelayMs(300);   HT1632_ALLRAM_OFF();
                      HT1632_Write_AddrLenDat(HT1632_CS2,0x20,16,0xff);
                      DelayMs(525);   //HT1632_ALLRAM_OFF();
              //      HT1632_Write_AddrLenDat(HT1632_CS2,0x30,8,0xff);
              //      DelayMs(300);
                      //全灭
                      HT1632_ALLRAM_OFF();
              //      DelayMs(100);
              }
              
              
              /*******************************************************************************
                                                      拷贝指定字符的显示内容控制数组到目标数组中
                  input:   none     
                      output:  none
              *******************************************************************************/
                      
              
              void AssCopyDispDataArry(INT8U *DestData,INT8U DispContent)
              {
                      INT8U i;//addr LED 显示位置
                      
              
                      if(DispContent >= LED_TBL_MAX)
                      { DispContent = ' '; } 
              
                      for(i = 0;i < LED_RANKCOUNT;i++)        
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 10  

                      { DestData[i] = LED_TBL[DispContent][i]; }
              }
              
              /*******************************************************************************
                                                              显示数据重组，存入buffer数组中
                  input:   none     
                      output:  none
              *******************************************************************************/        
              void    Disp_Data_Roll_Recombine_com(INT8U XDATA *ptr1)
              {
                      INT8U j, temp1,temp2;//,temp3;
                      INT8U tmp1[8],tmp2[8];//,tmp3[8]
              
                      //0
                      AssCopyDispDataArry((tmp1),Buffer[0]);
                      AssCopyDispDataArry((tmp2),Buffer[1]);
                      for(j = 0; j < LED_RANKCOUNT; j++)
                      {
                              temp1 = (tmp1[j]<<0)&0XFC;      //1.低6位
                              temp2 = (tmp2[j]>>6)&0X03;      //2.高2位
                              *(ptr1+j)  = temp1 | temp2;
                      }
                      //1
                      ptr1 += LED_RANKCOUNT;
              //              AssCopyDispDataArry((tmp1),DigiLed.Srcode[1]);
                      AssCopyDispDataArry((tmp1),Buffer[2]);
                      for(j = 0; j < LED_RANKCOUNT; j++)
                      {
                              temp1 = (tmp2[j]<<2)&0XF0;   //2.低4位
                              temp2 = (tmp1[j]>>4)&0X0F;      //3.高4位
                              *(ptr1+j)  = temp1 | temp2;
                      }
                      //2
                      ptr1 += LED_RANKCOUNT;
              //      AssCopyDispDataArry((tmp1),DigiLed.Srcode[2]);
                      AssCopyDispDataArry((tmp2),Buffer[3]);
                      for(j = 0; j < LED_RANKCOUNT; j++)
                      {
                              temp1 = (tmp1[j]<<4)&0XC0;   //3.低2位
                              temp2 = (tmp2[j]>>2)&0X3F;      //4.高6位
                              *(ptr1+j)  = temp1 | temp2; 
                      }
              }
              
              void    Disp_Data_Roll_Recombine(INT8U  area)
              {
                      INT8U i,j,dat;
              
              
                      if(area == SRCODE_AREA_ALL)
                      {
                              //0
                              for(i = 0,j = 0; i < 4; i++,j++)
                              { 
                                 if (j <  MAX_SRCODE_NUM )
                                              { dat = DigiLed.Srcode[j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }
                              Disp_Data_Roll_Recombine_com(&SRCodeData[0][0]);
              
                              //3
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 11  

                              for(i = 0,j = 4; i < 4; i++,j++)
                              { 
                                 if (j <  MAX_SRCODE_NUM )
                                              { dat = DigiLed.Srcode[j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }               
                              Disp_Data_Roll_Recombine_com(&SRCodeData[3][0]);
              
                              //6
                              for(i = 0,j = 8; i < 4; i++,j++)
                              { 
                                 if (j <  MAX_SRCODE_NUM )
                                              { dat = DigiLed.Srcode[j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }
                              Disp_Data_Roll_Recombine_com(&SRCodeData[6][0]);        
              
                              //9
                              for(i = 0,j = 12; i < 4; i++,j++)
                              { 
                                 if (j <  MAX_SRCODE_NUM )
                                              { dat = DigiLed.Srcode[j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }
                              Disp_Data_Roll_Recombine_com(&SRCodeData[9][0]);
                              
                              //12
                              for(i = 0,j = 16; i < 4; i++,j++)
                              { 
                                 if (j <  MAX_SRCODE_NUM )
                                              { dat = DigiLed.Srcode[j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }
                              Disp_Data_Roll_Recombine_com(&SRCodeData[12][0]);
              
                              //15
                              for(i = 0,j = 20; i < 4; i++,j++)
                              { 
                                 if (j <  MAX_SRCODE_NUM )
                                              { dat = DigiLed.Srcode[j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }
                              Disp_Data_Roll_Recombine_com(&SRCodeData[15][0]);
                              
                              //18
              //              for(i = 0,j = 24; i < 4; i++,j++)
              //              { 
              //                 if (j <  MAX_SRCODE_NUM )
              //                              { dat = DigiLed.Srcode[j]; }
              //                 else { dat = DIGI_LED_OFF; }
              //                 Buffer[i] = dat; 
              //              }
              //              Disp_Data_Roll_Recombine_com(&SRCodeData[18][0]);
                                                                                      
                      }
                      else  if(area == COUNT_AREA)
                      {
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 12  

                              //0
                              if( (DigiLed.CntLen > 4)&&(KeyMode.f_ChangeValue == OFF) )
                                      { j = 0; }
                              else{ j = 1; }
              
                              for(i = 0; i < 4; i++,j++)
                              { 
                                 if (j <  DIGILED_COUNT )
                                              { dat = DigiLed.num[2+j]; }
                                 else { dat = DIGI_LED_OFF; }
                                 Buffer[i] = dat; 
                              }
                              Disp_Data_Roll_Recombine_com(&CountCodeData[0][0]);     
              
                              //1
                              if( (DigiLed.CntLen > 4)&&(KeyMode.f_ChangeValue == OFF) )
                              {
                                      for(i = 0,j = 4; i < 4; i++,j++)
                                      { 
                                         if (j <  DIGILED_COUNT )
                                                      { dat = DigiLed.num[2+j]; }
                                         else { dat = DIGI_LED_OFF; }
                                         Buffer[i] = dat; 
                                      }
                                      Disp_Data_Roll_Recombine_com(&CountCodeData[3][0]);     
                              }               
                      }
                      else 
                      {
                              AssCopyDispDataArry(&Buffer[0],DigiLed.num[0]);
                              for(j = 0; j < LED_RANKCOUNT; j++)
                              {
                                      SKUCodeData[0][j] = (Buffer[j]>>2) & 0X3F;;             //
                              }
              
                              AssCopyDispDataArry(&Buffer[0],DigiLed.num[1]);
                              for(j = 0; j < LED_RANKCOUNT; j++)
                              {
                                      SKUCodeData[1][j] = (Buffer[j]>>1) & 0X7F;;
                              }                       
                      }
              
              }
              
              
              /*******************************************************************************
                                                      滚屏显示        只有任务运行模式和回显模式才进入
                  input:   none     
                      output:  none
              *******************************************************************************/
              //序列号支持滚动
              void ROLLING_SRDATA(UINT8 length)
              {
                      INT8U i,j,temp,startdata[LED_RANKCOUNT];
                      
                      if(length > MAX_SRCODE_NUM) length = MAX_SRCODE_NUM;
              
                      //先记下第一列
                      for(i = 0; i < LED_RANKCOUNT; i++)
                              startdata[i] = (SRCodeData[0][i] >>7)&0x01;
                      //后续的前挪
                      for(i = 0; i< length-1; i++)
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 13  

                      {
                              for(j = 0; j<LED_RANKCOUNT; j++)
                              {       
                                      //后面内容的最高位
                                      temp = (SRCodeData[i+1][j] >>7)&0x01;
                                      //前移一位 + 后面内容的最高位
                                      SRCodeData[i][j] = ((SRCodeData[i][j]<<1)&0xFE) + temp;                 
                              }
                      }
                      //最后一个内容 
                      for(j = 0; j<LED_RANKCOUNT; j++)
                      {       
                              SRCodeData[i][j] = ((SRCodeData[i][j]<<1)&0xFE) + startdata[j];                 
                      }
              }
              
              //序列号支持滚动
              void ROLLING_COUNTDATA(UINT8 length)
              {
                      INT8U i,j,temp,startdata[LED_RANKCOUNT];
                      
                      if(length > DIGILED_COUNT) length = DIGILED_COUNT;
              
                      //先记下第一列
                      for(i = 0; i < LED_RANKCOUNT; i++)
                              startdata[i] = (CountCodeData[0][i] >>7)&0x01;
                      //后续的前挪
                      for(i = 0; i< length-1; i++)
                      {
                              for(j = 0; j<LED_RANKCOUNT; j++)
                              {       
                                      //后面内容的最高位
                                      temp = (CountCodeData[i+1][j] >>7)&0x01;
                                      //前移一位 + 后面内容的最高位
                                      CountCodeData[i][j] = ((CountCodeData[i][j]<<1)&0xFE) + temp;                   
                              }
                      }
                      //最后一个内容 
                      for(j = 0; j<LED_RANKCOUNT; j++)
                      {       
                              CountCodeData[i][j] = ((CountCodeData[i][j]<<1)&0xFE) + startdata[j];                   
                      }
              }
              /*******************************************************************************
                                                      滚屏显示        只有任务运行模式和回显模式才进入
                  input:   none     
                      output:  none
              *******************************************************************************/
              void Disp_Roll_Process(void)
              {
                      INT8U nLength ;
              
                      // 滚屏定时时间未到则返回
                      if(Disp.RollDelayCnt != 0) return;
                      Disp.RollDelayCnt       = DISP_ROLL_SPEED;                              //滚屏定时值赋值
              
                      if(para.str.DispMode == 0X01)
                      {       // 批次信息区域滚屏
                              if(DigiLed.SrLen > 10)
                              {
                                      //根据显示内容字符数计算实际需要的LED模组数量
                                      // 8,9,10,11对应空余8，10，12，14间隔
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 14  

                                      nLength = DigiLed.SrLen - DigiLed.SrLen/4;
              
                                      ROLLING_SRDATA(nLength+1);                      
                                      HT1632_Write_AddrLenPtr(HT1632_CS1,0x00,32,&SRCodeData[0][0]);            // 把数据写入HTC1632
                                      HT1632_Write_AddrLenPtr(HT1632_CS2,0x00,32,&SRCodeData[4][0]);    // 把数据写入HTC1632
                              } 
                      }
                      else
                      {
                              // 批次信息区域滚屏
                              if(DigiLed.SrLen > 4) 
                              {       
                                      //根据显示内容字符数计算实际需要的LED模组数量
                                      // 8,9,10,11对应空余8，10，12，14间隔
                                      nLength = DigiLed.SrLen - DigiLed.SrLen/4;
              
                                      ROLLING_SRDATA(nLength+1);                      
                                      HT1632_Write_AddrLenPtr(HT1632_CS1,0x00,24,&SRCodeData[0][0]);            // 把数据写入HTC1632
                              }
                              // 数据区域滚屏
                              if( (DigiLed.CntLen > 4)&&(KeyMode.f_ChangeValue == OFF) )
                              {
                                      //根据显示内容字符数计算实际需要的LED模组数量
                                      ROLLING_COUNTDATA(6);                     // 5*8列，实际有效5*6列，空余10列作为间隔                     
                                      HT1632_Write_AddrLenPtr(HT1632_CS2,0x10,24,&CountCodeData[0][0]);                 // 把数据写入HTC1632
                              }
                              // 库位区域数据
                              Disp_Data_Roll_Recombine(SKU_AREA);
                              HT1632_Write_AddrLenPtr(HT1632_CS1,0x30,8,&SKUCodeData[0][0]);            // 把数据写入HTC1632
                              HT1632_Write_AddrLenPtr(HT1632_CS2,0x00,8,&SKUCodeData[1][0]);            // 把数据写入HTC1632
                      }
              }
              
              /*******************************************************************************
                                          HT1632 各区域刷新显示            
                  Input :      UINT8 ucValue   //LED_RED, LED_GREEN, LED_BLUE 
                  Output:  None       
              *******************************************************************************/
              void    Digi_DotLed_Disp(void)
              {       
              
                      // 批次信息区域
                      if( ((Disp.f_Rolling & ROLL_MODE_SRCINFO) == 0x00)||((Disp.f_Rolling & ROLL_MODE_SRCINFO_ED) != 0x00)  )
                      {       // 非滚屏模式 或 滚屏模式但允许数据区更新
                              // 批次号区域数据,
                              Disp_Data_Roll_Recombine(SRCODE_AREA_ALL);
                              Disp.f_Rolling &= ~ROLL_MODE_SRCINFO_ED;        
                      }
              
                      // 如果为文本显示模式，则不显示库位和数量区
              
                      if( (para.str.DispMode == 0X01)&&((Disp.Page == PAGE_RUN)||(Disp.Page == PAGE_BACKDISPLAY)) )
                      { 
                              HT1632_Write_AddrLenPtr(HT1632_CS1,0x00,32,&SRCodeData[0][0]);            // 把数据写入HTC1632
                              HT1632_Write_AddrLenPtr(HT1632_CS2,0x00,32,&SRCodeData[4][0]);            // 把数据写入HTC1632
                              return;
                      }
                      // 写入批次信息区域
                      HT1632_Write_AddrLenPtr(HT1632_CS1,0x00,24,&SRCodeData[0][0]);            // 把数据写入HTC1632
              
                      // 数量信息区域
                      if( ((Disp.f_Rolling & ROLL_MODE_COUNT) == 0x00)||((Disp.f_Rolling & ROLL_MODE_COUNT_ED) != 0x00)  )
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 15  

                      {
                              Disp_Data_Roll_Recombine(COUNT_AREA);
                              Disp.f_Rolling &= ~ROLL_MODE_COUNT_ED;
                      }
                      // 写入数量信息区域
                      HT1632_Write_AddrLenPtr(HT1632_CS2,0x10,24,&CountCodeData[0][0]);                 // 把数据写入HTC1632
              
                      // 库位信息区域
                      Disp_Data_Roll_Recombine(SKU_AREA);
                      HT1632_Write_AddrLenPtr(HT1632_CS1,0x30,8,&SKUCodeData[0][0]);            // 把数据写入HTC1632
                      HT1632_Write_AddrLenPtr(HT1632_CS2,0x00,8,&SKUCodeData[1][0]);            // 把数据写入HTC1632
              
              }
                      #endif
              #endif
 874          
 875          
 876          
 877          ///===================================================================================
 878          // 公共部分
 879          
 880          
 881          /************************************************************************
 882          ** 功能描述： 显示000～999(考虑字节长度，提高运算速度)
 883          ** 输入声明:  Order   ： 数据区的偏移地址，
 884                        ASICREL ：数字码是否要变ASCII码
 885                        Dat     : 数据
 886          ************************************************************************/
 887          void Calc_Value3(INT8U Order,INT8U ASICREL,INT16U Dat)
 888          {               
 889   1              INT8U  residue08;
 890   1              Dat = Dat%1000; 
 891   1              Buffer[Order++] = ASICREL + (Dat / 100);
 892   1              residue08 = (Dat % 100);
 893   1              Buffer[Order++] = ASICREL + (residue08 / 10);
 894   1              Buffer[Order]   = ASICREL + (residue08 % 10);   
 895   1      }
 896          
 897          /************************************************************************
 898          ** 功能描述： 显示0000～9999(考虑字节长度，提高运算速度)
 899          ** 输入声明:  Order   ： 数据区的偏移地址，
 900                        ASICREL ：数字码是否要变ASCII码
 901                        Dat     : 数据 0-9999
 902          ************************************************************************/
 903          
 904          void Calc_Value4(INT8U Order,INT8U ASICREL,INT16U Dat)
 905          {                       
 906   1              Dat = Dat%10000;
 907   1              Buffer[Order++] = (Dat / 1000) + ASICREL;
 908   1              Calc_Value3(Order,ASICREL,Dat);
 909   1      }
 910          
 911          /************************************************************************
 912          ** 功能描述： 显示0000～9999(考虑字节长度，提高运算速度)
 913          ** 输入声明:  Order   ： 数据区的偏移地址，
 914                        ASICREL ：数字码是否要变ASCII码
 915                        Dat     : 数据 0-9999
 916          ************************************************************************/
 917          
 918          void Calc_Value5(INT8U Order,INT8U ASICREL,INT16U Dat)
 919          {                       
 920   1              Buffer[Order++] = (Dat / 10000) + ASICREL;
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 16  

 921   1              Calc_Value4(Order,ASICREL,Dat);
 922   1      }
 923          
 924          /************************************************************************
 925          ** 功能描述： 前导0灭显示
 926          ** 输入声明:  Order   ： 数据区的偏移地址，
 927          ************************************************************************/
 928          void Disp0ChgOff(INT8U Order,INT8U len)
 929          {                       
 930   1              INT8U   i;
 931   1      
 932   1              for(i = 0; i < len;i++)
 933   1              {
 934   2                      if( (Buffer[Order+i] != '0')&&(Buffer[Order+i] != 0) )
 935   2                      { break; }
 936   2                      Buffer[Order+i] = DIGI_LED_OFF;//灭显示
 937   2              }
 938   1      }
 939          
 940          /*******************************************************************************
 941                                                          配置密码显示页面
 942              input:   none     
 943                  output:  none
 944          *******************************************************************************/
 945          void DispBuffrefresh_CFGPWD(void)
 946          {
 947   1              UINT8 i;                
 948   1      
 949   1              // 亮的
 950   1              for (i = DIGILED_FIRST; i < LED_NUMBER; i++)
 951   1              { DigiLed.num[i] = '-'; }
 952   1      
 953   1              if(Key.CfgPwdCnt != 0)
 954   1              { DigiLed.num[LED_NUMBER-1] = Key.CfgPwdCnt; }
 955   1      }
 956          /*******************************************************************************
 957                                                          更新显示数据区_全为灭
 958              input:   none     
 959                  output:  none
 960          *******************************************************************************/
 961          void DispBuffrefresh_OFF(void)
 962          {
 963   1              INT8U   i;
 964   1              DigiLed.SrLen = 4;      
 965   1              for (i = 0; i < MAX_SRCODE_NUM; i++)
 966   1              { DigiLed.Srcode[i]  = DIGI_LED_OFF; }
 967   1      
 968   1              for (i = DIGILED_FIRST; i < LED_NUMBER; i++)
 969   1              { DigiLed.num[i]   = DIGI_LED_OFF;      }
 970   1      }
 971          
 972          /*******************************************************************************
 973                                                          更新显示数据区F1
 974              input:   none     
 975                  output:  none
 976          *******************************************************************************/
 977          void DispBuffrefresh_AD(void)
 978          {
 979   1      
 980   1              DispBuffrefresh_OFF();          // 灭全部显示
 981   1      
 982   1      //#if    ( (DIGILED_SKU >= 2)&&(DIGILED_COUNT >= 3) )
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 17  

 983   1      if( (os_disp_set.DispLed_count >= 5)||((os_disp_set.DispLed_sku >= 2)&&(os_disp_set.DispLed_count >= 3)) )
 984   1      {
 985   2              DigiLed.num[DIGILED_FIRST]   = 'A';                    
 986   2          DigiLed.num[DIGILED_FIRST+1] = 'd'; 
 987   2      }
 988   1      //#endif                    
 989   1              
 990   1              DigiLed.CntLen = 3;
 991   1              Calc_Value3(0,0,para_bk.str.address);           
 992   1      
 993   1              if( KeyMode.f_Config == OFF )
 994   1              { Disp0ChgOff(0,2); }
 995   1              else if( Disp.f_OffDisp == ON )
 996   1              { Buffer[Disp.Focus] = DIGI_LED_OFF; } 
 997   1      
 998   1              DigiLed.num[LED_NUMBER-3] = Buffer[0];                 
 999   1              DigiLed.num[LED_NUMBER-2] = Buffer[1];
1000   1              DigiLed.num[LED_NUMBER-1] = Buffer[2];
1001   1      }
1002          /*******************************************************************************
1003                                                          更新显示数据区Fn共用
1004              input:   none     
1005                  output:  none
1006          *******************************************************************************/
1007          void DispBuffrefresh_FnCom(INT8U fn)
1008          {
1009   1              DispBuffrefresh_OFF();                           // 灭全部显示
1010   1              
1011   1      //#if    (DIGILED_SKU >= 2)
1012   1      if      ( (os_disp_set.DispLed_sku >= 2)||(os_disp_set.DispLed_count >= 5) )
1013   1      {
1014   2              DigiLed.num[DIGILED_FIRST]   = 'F';
1015   2              DigiLed.num[DIGILED_FIRST+1] = '0'+fn;
1016   2      }
1017   1      else
1018   1      {
1019   2      //#else
1020   2              DigiLed.num[LED_NUMBER-3] = 'F';
1021   2              DigiLed.num[LED_NUMBER-2] = '0'+fn;
1022   2      }
1023   1      //#endif
1024   1      
1025   1              DigiLed.CntLen = 1;
1026   1              if( (KeyMode.f_Config == OFF)||(Disp.f_OffDisp == OFF) )
1027   1              {
1028   2                 switch(fn)
1029   2                 {
1030   3                              case 1:    DigiLed.num[LED_NUMBER-1] = para_bk.str.FinishedLED; break;
1031   3                              case 2:    DigiLed.num[LED_NUMBER-1] = para_bk.str.WtTime;      break;
1032   3                              case 3:    DigiLed.num[LED_NUMBER-1] = para_bk.str.FnDefine;    break;
1033   3                              case 4:    DigiLed.num[LED_NUMBER-1] = para_bk.str.DispMode;    break;
1034   3                              case 5:    DigiLed.num[LED_NUMBER-1] = para_bk.str.KeyProssLED; break;
1035   3                 }
1036   2              }
1037   1      }
1038          
1039          /*******************************************************************************
1040                                                          更新显示数据区F1
1041              input:   none     
1042                  output:  none
1043          *******************************************************************************/
1044          void DispBuffrefresh_F1(void)
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 18  

1045          {                      
1046   1      
1047   1              DispBuffrefresh_FnCom(1);
1048   1      }
1049          
1050          /*******************************************************************************
1051                                                          更新显示数据区F2
1052              input:   none     
1053                  output:  none
1054          *******************************************************************************/
1055          void DispBuffrefresh_F2(void)
1056          {                       
1057   1              DispBuffrefresh_FnCom(2);
1058   1      }
1059          
1060          /*******************************************************************************
1061                                                          更新显示数据区F3
1062              input:   none     
1063                  output:  none
1064          *******************************************************************************/
1065          void DispBuffrefresh_F3(void)
1066          {                      
1067   1              DispBuffrefresh_FnCom(3);
1068   1      }
1069          
1070          /*******************************************************************************
1071                                                          更新显示数据区F4
1072              input:   none     
1073                  output:  none
1074          *******************************************************************************/
1075          void DispBuffrefresh_F4(void)
1076          {                       
1077   1              DispBuffrefresh_FnCom(4);
1078   1      }
1079          
1080          /*******************************************************************************
1081                                                          更新显示数据区F4
1082              input:   none     
1083                  output:  none
1084          *******************************************************************************/
1085          void DispBuffrefresh_F5(void)
1086          {                       
1087   1              DispBuffrefresh_FnCom(5);
1088   1      }
1089          /*******************************************************************************
1090                                                          更新显示数据区F4
1091              input:   none     
1092                  output:  none
1093          *******************************************************************************/
1094          void DispBuffrefresh_Wait(void)
1095          {
1096   1              UINT8 i;                
1097   1              if(Disp.Shift > LED_NUMBER)
1098   1              { Disp.Shift = DIGILED_FIRST; }
1099   1              // 亮的
1100   1              for (i = DIGILED_FIRST; i < Disp.Shift; i++)
1101   1              { DigiLed.num[i] = '-'; }
1102   1              // 灭的
1103   1              for (i = Disp.Shift; i < LED_NUMBER; i++)
1104   1              { DigiLed.num[i] = DIGI_LED_OFF; }
1105   1      
1106   1              DigiLed.CntLen = 4;
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 19  

1107   1              // 批次信息区数据更新
1108   1              DigiLed.SrLen  = 4;
1109   1      
1110   1              DigiLed.Srcode[0] = 'W'; 
1111   1              DigiLed.Srcode[1] = 'a';
1112   1              DigiLed.Srcode[2] = 'i';
1113   1              DigiLed.Srcode[3] = 't';
1114   1              for(i = 4;i < MAX_SRCODE_NUM;i++)
1115   1              { DigiLed.Srcode[i] = DIGI_LED_OFF; }
1116   1      }
1117          
1118          /*******************************************************************************
1119                                                          显示相同字符
1120              input:   none     
1121                  output:  none
1122          *******************************************************************************/
1123          
1124          void    DispSameChar(INT8U      DispChar)
1125          {
1126   1              INT8U   i;
1127   1              for (i = DIGILED_FIRST; i < LED_NUMBER; i++)
1128   1              { DigiLed.num[i]   = DispChar;  }
1129   1      }
1130          
1131          /*******************************************************************************
1132                                                          更新显示数据区_任务回显共用
1133              input:   none     
1134                  output:  none
1135          *******************************************************************************/
1136          void    DispBuffrefresh_Task_Back_com(TASK_INFO XDATA *ptr)
1137          {
1138   1              INT8U   i,len,dat;
1139   1              INT16U   usValue;
1140   1              
1141   1              DispBuffrefresh_OFF();          // 灭全部显示
1142   1              dat     = (*ptr).sku;
1143   1              usValue = (*ptr).count;
1144   1              len     = (*ptr).srcode_len;
1145   1      
1146   1      
1147   1      
1148   1              // 库位区数据更新
1149   1      //#if     (DIGILED_SKU == 3)  
1150   1      if(os_disp_set.DispLed_sku == 3)
1151   1      {
1152   2              DigiLed.num[DIGILED_FIRST+0] = (*ptr).srcode[len-3];//DispContentStack_SrCode[CurBackDispIndex][DispConte
             -ntStack_SrCodeLen[CurBackDispIndex]-3];       //货位号高位
1153   2              DigiLed.num[DIGILED_FIRST+1] = (*ptr).srcode[len-2];//DispContentStack_SrCode[CurBackDispIndex][DispConte
             -ntStack_SrCodeLen[CurBackDispIndex]-2];       //货位号低位
1154   2              DigiLed.num[DIGILED_FIRST+2] = (*ptr).srcode[len-1];//DispContentStack_SrCode[CurBackDispIndex][DispConte
             -ntStack_SrCodeLen[CurBackDispIndex]-1]; 
1155   2      }
1156   1      else if(os_disp_set.DispLed_sku == 2)
1157   1      {
1158   2      //#elif (DIGILED_SKU == 2)     
1159   2              // 库位号不等于FF则显示
1160   2              if(dat != 0xff)
1161   2              {                        
1162   3                      DigiLed.num[DIGILED_FIRST+0] = (dat>>4) & 0X0F;//(UINT8)((DispContentStack_NO[CurBackDispIndex]>>4) &0X0
             -F);                //货位号高位
1163   3                      DigiLed.num[DIGILED_FIRST+1] =      dat & 0X0F;//(UINT8)(DispContentStack_NO[CurBackDispIndex] &0X0F);  
             -                  //货位号低位
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 20  

1164   3              }       
1165   2      }
1166   1      //#endif 
1167   1      
1168   1              if(usValue > 9999)
1169   1              { DigiLed.CntLen = 5; }
1170   1              else if(usValue > 999)
1171   1              { DigiLed.CntLen = 4; }
1172   1              else if(usValue > 99)
1173   1              { DigiLed.CntLen = 3; }
1174   1              else if(usValue > 9)
1175   1              { DigiLed.CntLen = 2; }
1176   1              else 
1177   1              { DigiLed.CntLen = 1; }
1178   1      
1179   1      //      if( DigiLed.CntLen > DIGILED_COUNT)
1180   1      //      { DigiLed.CntLen = DIGILED_COUNT; }
1181   1              if( DigiLed.CntLen > os_disp_set.DispLed_count)
1182   1              { DigiLed.CntLen = os_disp_set.DispLed_count; }
1183   1      
1184   1              // 批次信息区数据更新
1185   1              DigiLed.SrLen  = len;
1186   1              for(i = 0;i < len;i++)
1187   1              { DigiLed.Srcode[i] = (*ptr).srcode[i]; }
1188   1      
1189   1         // 数量区数据更新
1190   1              if(Key.f_IsFnKeyPressed == ON)
1191   1              {       //显示"----"   满箱操作
1192   2                      DigiLed.CntLen = 0;
1193   2            
1194   2      //              for(i = 1; i <= DIGILED_COUNT; i++)
1195   2                      for(i = 1; i <= os_disp_set.DispLed_count; i++)
1196   2                      { DigiLed.num[LED_NUMBER-i] = '-'; }
1197   2              }
1198   1              else if(para.str.DispMode == 0X01)      //字符显示型
1199   1              {       // 字符型数据和3位库位的信息一致了
1200   2                      DigiLed.CntLen = 0;
1201   2      
1202   2                      if(len > LED_NUMBER)
1203   2                              { len -= LED_NUMBER; }
1204   2                      else{ len = 0; }
1205   2      
1206   2                      for(i = 0; i < LED_NUMBER; i++,len++)
1207   2                      {       // 只显示0~9，A~Z，a~z，-，其他都灭
1208   3      
1209   3                              dat = DigiLed.Srcode[len];
1210   3      
1211   3                              if( (dat > 'z')||((dat < '0')&&(dat != '-'))
1212   3                                ||((dat > '9')&&(dat  < 'A'))||((dat > 'Z')&&(dat  < 'a'))  )
1213   3                              { dat = DIGI_LED_OFF; }   //灭显示
1214   3      
1215   3                              DigiLed.num[DIGILED_FIRST + i] =   dat;            //添加偏移量 DIGILED_FIRST
1216   3                      }                               
1217   2              }
1218   1      //      else  if(usValue < DISPLAY_MAX_NUM)     //任务显示型
1219   1              else  if(usValue < os_disp_set.DispMax_count)   //任务显示型
1220   1              {                       
1221   2                      Calc_Value5(0,0,usValue);
1222   2                      if( KeyMode.f_ChangeValue == OFF )
1223   2                      { Disp0ChgOff(0,COUNT_MAX-1); }                   // 灭数量前导0
1224   2                      else if( Disp.f_OffDisp == ON )                   // 设置数量时，对应焦点位闪烁
1225   2      //              { Buffer[Disp.Focus+(COUNT_MAX-DIGILED_COUNT)] = DIGI_LED_OFF; }  
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 21  

1226   2                      { Buffer[Disp.Focus+(COUNT_MAX-os_disp_set.DispLed_count)] = DIGI_LED_OFF; }  
1227   2                      // 把显示的数据放入对应位显示存储区
1228   2      //              for(i = 1; i <= DIGILED_COUNT; i++)
1229   2                      for(i = 1; i <= os_disp_set.DispLed_count; i++)
1230   2                      { DigiLed.num[LED_NUMBER-i] = Buffer[COUNT_MAX-i]; }                    
1231   2              }
1232   1              else 
1233   1              {   //显示"FULL"
1234   2      //      #if  (DIGILED_COUNT == 2)
1235   2              if  (os_disp_set.DispLed_count == 2)
1236   2              {
1237   3                      DigiLed.num[LED_NUMBER-2] = 'o';//-'A'+10;
1238   3                      DigiLed.num[LED_NUMBER-1] = 'v';//-'A'+10; 
1239   3              }
1240   2              else if(os_disp_set.DispLed_count == 3)
1241   2              {
1242   3      //      #elif(DIGILED_COUNT == 3)
1243   3                      DigiLed.num[LED_NUMBER-3] = 'F';//-'A'+10; 
1244   3                      DigiLed.num[LED_NUMBER-2] = 'U';//-'A'+10;
1245   3                      DigiLed.num[LED_NUMBER-1] = 'L';//-'A'+10; 
1246   3              }
1247   2              else if(os_disp_set.DispLed_count >= 4)
1248   2              {
1249   3      //      #elif (DIGILED_COUNT >= 4) //(DIGILED_COUNT == 5)
1250   3                      DigiLed.num[LED_NUMBER-4] = 'F';//-'A'+10; 
1251   3                      DigiLed.num[LED_NUMBER-3] = 'U';//-'A'+10;
1252   3                      DigiLed.num[LED_NUMBER-2] = 'L';//-'A'+10;
1253   3                      DigiLed.num[LED_NUMBER-1] = 'L';//-'A'+10; 
1254   3      //      #endif
1255   3              }                                             
1256   2              }
1257   1      
1258   1                      
1259   1              // 设置批次信息滚屏标志和刷新滚屏数据区标志
1260   1              if( ((para.str.DispMode == 0X01)&&(DigiLed.SrLen > 10))
1261   1           ||((para.str.DispMode == 0X00)&&(DigiLed.SrLen > 4)) )
1262   1              {
1263   2                      if((Disp.f_Rolling & ROLL_MODE_SRCINFO) == 0x00)
1264   2                      { Disp.f_Rolling |= (ROLL_MODE_SRCINFO|ROLL_MODE_SRCINFO_ED); }
1265   2              }
1266   1              else
1267   1              { Disp.f_Rolling &= ~(ROLL_MODE_SRCINFO|ROLL_MODE_SRCINFO_ED); }
1268   1      
1269   1              // 设置数量信息滚屏标志和刷新滚屏数据区标志               
1270   1              if((para.str.DispMode == 0X00)&&(DigiLed.CntLen > 4)&&(KeyMode.f_ChangeValue == OFF)) 
1271   1              {
1272   2                      if((Disp.f_Rolling & ROLL_MODE_COUNT) == 0x00)
1273   2                      { Disp.f_Rolling |= (ROLL_MODE_COUNT | ROLL_MODE_COUNT_ED); }   
1274   2              }
1275   1              else{ Disp.f_Rolling &= ~(ROLL_MODE_COUNT | ROLL_MODE_COUNT_ED); }
1276   1      }
1277          
1278          /*******************************************************************************
1279                                                          更新显示数据区_回显用
1280              input:   none     
1281                  output:  none
1282          *******************************************************************************/
1283          void DispBuffrefresh_BackDisp(void)
1284          {
1285   1              DispBuffrefresh_Task_Back_com(&BackTask.info[BackTask.index]);
1286   1      }
1287          
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 22  

1288          /*******************************************************************************
1289                                                          更新显示数据区_作业显示
1290              input:   none     
1291                  output:  none
1292          *******************************************************************************/
1293          void DispBuffrefresh_TaskProcess(void)
1294          {
1295   1              DispBuffrefresh_Task_Back_com(&UnfinishTask.info[0]);
1296   1      }
1297          
1298          /*******************************************************************************
1299                                                          更新显示数据区_数据出错显示
1300              input:   none     
1301                  output:  none
1302          *******************************************************************************/
1303          void DispBuffrefresh_NULL(void)
1304          {
1305   1              INT8U   tmp = 0;
1306   1              DispBuffrefresh_OFF();          // 灭全部显示
1307   1      
1308   1      //      DigiLed.CntLen = 4;
1309   1      //#if    (DIGILED_SKU >= 2)
1310   1      //      
1311   1      //      DigiLed.num[0] = 'N';//-'A'+10;             //N
1312   1      //    DigiLed.num[1] = 'U';//-'A'+10;               //u
1313   1      //
1314   1      //      tmp = Disp.Value/256;
1315   1      //      DigiLed.num[LED_NUMBER-4] = ((tmp>>4)&0x0f);
1316   1      //      DigiLed.num[LED_NUMBER-3] = (tmp&0x0f);
1317   1      //
1318   1      //      tmp = (INT8U)Disp.Value;
1319   1      //      DigiLed.num[LED_NUMBER-2] = ((tmp>>4)&0x0f);
1320   1      //      DigiLed.num[LED_NUMBER-1] = (tmp&0x0f);
1321   1      //#else
1322   1      //      DigiLed.num[3] = 'N';//-'A'+10;             //N
1323   1      //    DigiLed.num[4] = 'U';//-'A'+10;               //u
1324   1      //      DigiLed.num[5] = 'L';//-'A'+10;             //u
1325   1      //#endif
1326   1      
1327   1      }
1328          
1329          
1330          
1331          
1332          /*******************************************************************************
1333                                      给当前显示led供电            
1334              Input :      UINT8 ucValue   //LED_RED, LED_GREEN, LED_BLUE 
1335              Output:  None       
1336          *******************************************************************************/
1337          void led_light_ctrl(UINT8 ucValue)
1338          {
1339   1              switch (ucValue)
1340   1              {
1341   2                      case LED_RED:           LED_G_OFF; LED_B_OFF;  LED_R_ON;  break;                
1342   2                      case LED_GREEN:         LED_R_OFF; LED_B_OFF;  LED_G_ON;  break;
1343   2                      case LED_BLUE:          LED_R_OFF; LED_G_OFF;  LED_B_ON;  break;
1344   2                      
1345   2                      case LED_RG:            LED_B_OFF; LED_R_ON;   LED_G_ON;  break;                
1346   2                      case LED_RB:            LED_G_OFF; LED_R_ON;   LED_B_ON;  break;
1347   2                      case LED_GB:            LED_R_OFF; LED_G_ON;   LED_B_ON;  break;
1348   2                      case LED_RGB:           LED_R_ON;  LED_G_ON;   LED_B_ON;  break;                        
1349   2                      default:                        LED_R_OFF; LED_G_OFF; LED_B_OFF;break;
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 23  

1350   2              }
1351   1      }
1352          
1353          /*******************************************************************************
1354                                          获取灯亮时间，单位ms
1355                  Input :         none
1356                  Output :        16位的灯亮时间，在系统时钟里自减该数值
1357          *******************************************************************************/
1358          
1359          void GetLedOnTime(void)
1360          {
1361   1              UINT16 unRet ;//= led_flash_period;
1362   1              switch(led.flash_mode)
1363   1              {
1364   2                      case LED_FLASH_MODE_2V1:                unRet = (INT16U)(led.flash_period*2) ;break;
1365   2                      case LED_FLASH_MODE_5V1:                unRet = (INT16U)(led.flash_period*5) ;break;
1366   2                      case LED_FLASH_MODE_10V1:               unRet = (INT16U)(led.flash_period*10);break;
1367   2                      default:                                                unRet = led.flash_period;       break;
1368   2              }
1369   1      
1370   1              led.time_refresh = unRet;               // 开灯闪烁时间
1371   1      }
1372          /*******************************************************************************
1373                                          获取灯灭时间，单位ms
1374                  Input :         none
1375                  Output :        16位的灯灭时间，在系统时钟里自减该数值
1376          *******************************************************************************/
1377          
1378          void GetLedOffTime(void)
1379          {
1380   1              UINT16 unRet ;//= led_flash_period;
1381   1              switch(led.flash_mode)
1382   1              {
1383   2                      case LED_FLASH_MODE_1V2:                unRet = (INT16U)(led.flash_period*2) ;break;
1384   2                      case LED_FLASH_MODE_1V5:                unRet = (INT16U)(led.flash_period*5) ;break;
1385   2                      case LED_FLASH_MODE_1V10:               unRet = (INT16U)(led.flash_period*10);break;
1386   2                      default:                                                unRet = led.flash_period;       break;          
1387   2              }
1388   1      
1389   1              led.time_refresh = unRet;               // 开灯闪烁时间
1390   1      }
1391          /*******************************************************************************
1392                                                          指示灯控制模式
1393          input:   
1394                      led_flash_period:  闪烁时间间隔
1395                      led_flash_NO:      闪烁灯序号
1396                      led_flash_mode:    闪烁模式
1397          output:  none                                   
1398          *******************************************************************************/
1399          void CMD_led_flash(void)
1400          {
1401   1              if(led.light_type == LED_NONE)
1402   1              {       // 全灭
1403   2                      led_light_ctrl(LED_NONE);               // 全灭
1404   2                      return;
1405   2              }
1406   1              // 显示对应灯色
1407   1              if(led.flash_mode == LED_FLASH_MODE_ALWAYS)     //常亮显示
1408   1              {   // 非闪烁模式
1409   2                      led_light_ctrl(led.light_type);                 // 仅点亮对应颜色
1410   2                      return;
1411   2              }
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 24  

1412   1              //闪烁显示      
1413   1              if(led.time_refresh == 0)
1414   1              { // 时间到状态改变
1415   2                //当前灯为灭状态
1416   2                      if(led.flash_status == 0)
1417   2                      {
1418   3                              //切换到灯亮状态，并且设置改变灯亮周期参数
1419   3                              led.flash_status = 1;                   // 切换到灯亮状态
1420   3                              led_light_ctrl(led.light_type); // 仅点亮对应颜色                       
1421   3                              GetLedOnTime();                                 // 取亮灯时间，系统时钟里自减到0
1422   3                      }
1423   2                      //当前为亮灯
1424   2                      else
1425   2                      {
1426   3                              //切换到灯灭状态，并且设置改变灯灭周期参数
1427   3                              led.flash_status = 0;                   //切换到灯亮状态
1428   3                              led_light_ctrl(LED_NONE);               // 全灭 
1429   3                              GetLedOffTime();        // 取灭灯时间，系统时钟里自减到0
1430   3                      }
1431   2              }
1432   1      }
1433          
1434          /*******************************************************************************
1435                                                          清除所有显示
1436           // 清除显示 // 包含清除数码管，灯组，清回显标志和配置标志，数值更改标志
1437                  input:   none     
1438                  output:  none                                   
1439          *******************************************************************************/
1440          void Display_Clear(void)
1441          {
1442   1              Key.f_LongFunc        = FALSE;          // 退出配置密码状态
1443   1              KeyMode.f_Config      = OFF;            // 退出配置状态
1444   1              KeyMode.f_BackDisp        = OFF;                // 退出回显状态                                    
1445   1              KeyMode.f_ChangeValue = OFF;            // 退出修改状态                                                                 
1446   1      //      BackTask.index = 0;             // 回显备份区的索引清0
1447   1              
1448   1              //显示信息清除  
1449   1              SetDispPage(PAGE_OFF);
1450   1              Disp.TatolTimeRefresh16 = DISP_IC_INI_PER; // 关闭页面下定时初始化IC
1451   1      //      DispSameChar(DIGI_LED_OFF);
1452   1              //指示灯清除
1453   1          led.light_type = LED_NONE;
1454   1      //      led_light_ctrl(LED_NONE);
1455   1      }
1456          
1457          
1458          /*****************************************************************
1459                                                          开机显示，版本号，各段码，
1460              input:   none     
1461                  output:  none
1462          *******************************************************************************/
1463          
1464          void Start_Display(void)
1465          {
1466   1              //显示版本 ，含延时时间
1467   1              DispVersion();
1468   1      
1469   1          //显示各段码   // 检测数码管
1470   1              DispLedBit();
1471   1      
1472   1              //显示全8
1473   1              DispSameChar('8');
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 25  

1474   1      
1475   1              //LED亮
1476   1              led_light_ctrl(LED_RED);                        // 仅亮红灯显示
1477   1              DelayMs(500);
1478   1      
1479   1              led_light_ctrl(LED_GREEN);                      // 仅亮绿灯显示
1480   1              DelayMs(500);
1481   1      
1482   1              led_light_ctrl(LED_BLUE);                       // 仅亮蓝灯显示
1483   1              DelayMs(500);
1484   1      
1485   1              // 数码管全灭
1486   1      //      DispSameChar(' ');
1487   1      
1488   1      //      led_light_ctrl(LED_RG);                 // 仅亮红绿灯显示
1489   1      //      DelayMs(500);
1490   1      //      led_light_ctrl(LED_RB);                 // 仅亮红蓝灯显示
1491   1      //      DelayMs(500);
1492   1      //      led_light_ctrl(LED_GB);                 // 仅亮绿蓝灯显示
1493   1      //      DelayMs(500);
1494   1              led_light_ctrl(LED_NONE);               // 灭所有显示
1495   1      
1496   1              Display_Para_AD_Fn();                   // 显示AD 地址,F1~F4参数
1497   1              Display_Clear();                                // 清除显示 // 包含清除数码管，灯组，清回显标志和配置标志，数值更改标志
1498   1      }
1499          
1500          /************************************************************************
1501          ** 功能描述：设置显示页面和显示层
1502          ** 输入 :   LcdPage 显示的页面 , 低7位代表页面，高位代表该页面可否覆盖
1503          ************************************************************************/
1504          void    SetDispPage(INT8U Page)
1505          {       
1506   1      //       digital_led_refresh = ON;                                               // 使能数据更新标志
1507   1               Disp.f_Refresh = ON;                                            // 使能数据更新标志
1508   1               Disp.Page = Page;
1509   1               if( (Page != PAGE_RUN)&&(Page != PAGE_BACKDISPLAY) )
1510   1               { Disp.f_Rolling = ROLL_MODE_OFF; }
1511   1      }
1512          
1513          /*******************************************************************************
1514                                      显示缓存区数据定时更新检测            
1515              Input :      None 
1516              Output:  None       
1517          *******************************************************************************/
1518          void    Time_LedDispBuffRefresh(void)
1519          {
1520   1              if(Disp.f_Refresh == OFF) 
1521   1              { 
1522   2                      if(Key.f_LongFunc == TRUE)
1523   2                      {  // 配置参数密码状态，超时退出
1524   3                              if( Disp.TatolTimeRefresh8 == 0 )
1525   3                              { 
1526   4                                      Display_Clear();                                                        // 清除显示 // 包含清除数码管，灯组，清回显标志和配置标志，数值更改标志
1527   4                              }
1528   3                      }               
1529   2                      else if( (KeyMode.f_Config == ON)||(KeyMode.f_ChangeValue == ON)        )
1530   2                      {
1531   3                              if( Disp.TatolTimeRefresh8 == 0 )
1532   3                              {  // 总超时时间到
1533   4                                      if(KeyMode.f_Config == ON)
1534   4                                      { Exit_Cfg_Mode();  }           // 退出配置页面
1535   4                                      else
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 26  

1536   4                                      {                                       
1537   5                                              Disp.Focus                      = 0;
1538   5                                              KeyMode.f_ChangeValue   = OFF;
1539   5                                              Disp.f_Refresh                  = ON;
1540   5                                      }           
1541   4                              }
1542   3                              else if(Disp.TimeRefresh == 0)
1543   3                              {       // 定时闪烁
1544   4                                      Disp.f_Refresh = ON;              //数码管更新
1545   4                                      
1546   4                                      if( Disp.f_OffDisp == OFF )
1547   4                                              { Disp.f_OffDisp = ON;  Disp.TimeRefresh = COUNT_FLICKER_OFF;  }
1548   4                                      else{ Disp.f_OffDisp = OFF; Disp.TimeRefresh = COUNT_FLICKER_ON; }                               
1549   4                              }               
1550   3                      }               
1551   2                      //显示LOADING 过程 '-' '--' '---' '----' '-----' '------'
1552   2                      else if((Disp.f_Loading != LOAD_MODE_OFF))
1553   2                      {                       
1554   3      //                      if(sys.digital_led_load_cnt == 0)
1555   3                              if(Disp.TatolTimeRefresh16 == 0)
1556   3                              {       // 总超时时间到
1557   4      
1558   4                                      Disp.f_Loading    = LOAD_MODE_OFF;                      // 结束等待进度条
1559   4                                      led.light_type    = led.light_type_BK;          // 恢复原先使用的灯组                            
1560   4                                      SetDispPage( PAGE_RUN );                                        // 等待完成进入工作页面              
1561   4                              }
1562   3                              else if(Disp.TimeRefresh == 0)
1563   3                              {       // 定时滚动
1564   4                                      Disp.f_Refresh   = ON;                                                  //数码管更新
1565   4                                      Disp.TimeRefresh = DIGITAL_LED_LOAD_CNT_PER;    //计数值赋值
1566   4                                      Disp.Shift++;
1567   4                              }               
1568   3                      }
1569   2         #if( (MACHINETYPE == P10_910U)||(MACHINETYPE == P10_910U_R10)||(MACHINETYPE == A10S_820) )
                              // HT1632C 复位
                              else  if(Disp.Page == PAGE_OFF)
                              {
                                      if(Disp.TatolTimeRefresh16 == 0)        
                                      { 
                                              Disp.TatolTimeRefresh16 = DISP_IC_INI_PER;
                                              digital_led_cntrl_Init();        // 数码管芯片初始化
                                      }
                              }
              
                              // 滚屏显示
                              if(Disp.f_Rolling != ROLL_MODE_OFF) 
                              {
                                      Disp_Roll_Process();                                                            //滚屏
                              }
                      #endif                                  
1586   2              }
1587   1      }
1588          
1589          /*******************************************************************************
1590                                      显示缓存区数据更新            
1591              Input :      None 
1592              Output:  None       
1593          *******************************************************************************/
1594          void    LedDispBuffRefresh(void)
1595          {
1596   1              
1597   1              Time_LedDispBuffRefresh();                      // 定时更新标志
C51 COMPILER V9.00   LED                                                                   10/09/2016 16:12:15 PAGE 27  

1598   1              // 无更新则退出
1599   1              if(Disp.f_Refresh == OFF) return; 
1600   1              // 有更新
1601   1              Disp.f_Refresh = OFF;                   // 清更新标志
1602   1      
1603   1              switch(Disp.Page)
1604   1              {               
1605   2                      case    PAGE_RUN:                       DispBuffrefresh_TaskProcess();  break;                    //运行页面
1606   2                      case    PAGE_WAIT:                      DispBuffrefresh_Wait();                 break;                    //等待（进度条）页面
1607   2                      case    PAGE_BACKDISPLAY:       DispBuffrefresh_BackDisp();     break;                    //回显页面
1608   2                      case    PAGE_CFGADDR:           DispBuffrefresh_AD();                   break;                    //配置地址页面
1609   2                      case    PAGE_CFGFUNC1:          DispBuffrefresh_F1();                   break;                    //配置功能1页面
1610   2                      case    PAGE_CFGFUNC2:          DispBuffrefresh_F2();                   break;                    //配置功能2页面
1611   2                      case    PAGE_CFGFUNC3:          DispBuffrefresh_F3();                   break;                    //配置功能3页面
1612   2                      case    PAGE_CFGFUNC4:          DispBuffrefresh_F4();                   break;                    //配置功能4页面
1613   2                      case    PAGE_CFGFUNC5:          DispBuffrefresh_F5();                   break;                    //配置功能4页面
1614   2                      case    PAGE_NULL:                      DispBuffrefresh_NULL();                 break;                    //NULL
1615   2      //              case    PAGE_START       :              Page_Start();                                   break;                    //开机页面
1616   2                      case    PAGE_CFGPWD:            DispBuffrefresh_CFGPWD();                       break;                    //配置密码页面
1617   2                      default :                                       DispBuffrefresh_OFF();              break;                        //灭显示                                                                                                              
1618   2              }
1619   1      
1620   1              // 
1621   1              Digi_DotLed_Disp();                             // 送芯片刷新显示
1622   1      }
1623          
1624          /*******************************************************************************
1625                                                                          END                                     
1626          *******************************************************************************/
1627          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1787    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
